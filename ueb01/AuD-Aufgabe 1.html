<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0063)http://intern.fh-wedel.de/~mhe/spaud/aud-aufgaben/aufgabe1.html -->
<html xml:lang="de" lang="de" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  

<title>AuD-Aufgabe 1</title>
</head>
<body>

  <div id="wrapper">
    <div id="container">

      <div id="content" class="twocolumns">


        <div id="col2">
          <div id="col2_content" class="clearfix">

            <!-- BEGIN: DOCUMENT COLUMN -->
<h1>Aufgabe 1</h1>
<p>In der ersten Aufgabe sollt ihr ein Programm zur Lösung linearer Optimierungsprobleme mit Hilfe des Simplex-Algorithmus erstellen
und euch dabei zudem mit der Einrichtung eurer Entwicklungsumgebung und mit diversen Tools (JUnit, Checkstyle, Ant, …)
befassen.</p>
<h2>Anforderungen und Tools</h2>
<p>Für die Tools und die spezifischen Anforderungen der AuD-Übung gibt es eine eigene <a href="http://intern.fh-wedel.de/~mhe/spaud/aud-anforderungen.html">Seite</a>, da diese für alle Aufgaben gültig sind. Bitte befasst euch ausgiebig mit den dort vorgestellten Tools und Konzepten und arbeitet das JUnit-Tutorial durch,
wenn ihr noch nicht genügend Erfahrungen mit diesem Framework habt.</p>
<h2>Aufgabenstellung</h2>
<p>In dieser Aufgabe geht es um die Verarbeitung allgemeiner lineare Probleme, also sowohl Maximierungs-
als auch Minimierungsprobleme mit jeweils <code class="highlight"><span class="o">&lt;=</span></code>-, <code class="highlight"><span class="o">&gt;=</span></code>- und <code class="highlight"><span class="o">=</span></code>-Restriktionen.</p>
<p>Zur Vereinfachung des Verfahrens gilt jedoch die
sogenannte Nichtnegativitätsbedingung, d.h. alle
Variablen des Problems müssen nicht-negativ sein (<code class="highlight"><span class="n">x1</span><span class="p">..</span><span class="n">xn</span> <span class="o">&gt;=</span> <span class="mi">0</span></code>). Das gleiche
gilt für die rechten Seiten (<code class="highlight"><span class="n">b1</span><span class="p">..</span><span class="n">bm</span> <span class="o">&gt;=</span> <span class="mi">0</span></code>). Ein Beispiel für ein konkretes
Optimierungsproblem ist:</p>
<div class="highlight"><pre><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="mi">4</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">&lt;=</span> <span class="mi">320</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">&gt;=</span> <span class="mi">100</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="mi">3</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x2</span>  <span class="o">=</span> <span class="mi">270</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span>  <span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">x2</span>  <span class="o">=</span> <span class="n">z</span> <span class="p">(</span><span class="n">MIN</span><span class="p">)</span>
</pre></div>

<h3>Das Simplexverfahren</h3>
<p>Ziel des Simplexverfahrens ist es, Werte für die Variablen (hier <code class="highlight"><span class="n">x1</span></code> und <code class="highlight"><span class="n">x2</span></code>) zu finden, welche
die Restriktionen (Zeile (1) bis (3)) erfüllen und für welche <code class="highlight"><span class="n">z</span></code> in der Zielfunktion (Zeile (4)) den
kleinst- bzw. größtmöglichen Wert annimmt.</p>
<h4>Änderung der Zielfunktion und Einführung von künstlichen Variablen</h4>
<p>Die Berücksichtigung von Minimierungsproblemen im Simplexverfahren ist durch Negation
der Zielfunktion zu erreichen – die negierte Zielfunktion “<code class="highlight"><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">x2</span></code>” zu maximieren
liefert das gleiche Ergebnis wie die Minimierung der ursprünglichen Zielfunktion.</p>
<p>Um die <code class="highlight"><span class="o">&lt;=</span></code>- und die <code class="highlight"><span class="o">&gt;=</span></code>-Restriktionsungleichungen für das Lösungsverfahren in Gleichungen
umzuformen, muss für jede dieser Restriktion eine zusätzliche Variable eingeführt werden,
eine sogenannte Schlupfvariable. Eine Schlupfvariable gleicht in ihrer
Restriktion den Unterschied zwischen der potenziell kleineren (für <code class="highlight"><span class="o">&lt;=</span></code>-Restikionen) bzw. größeren (für <code class="highlight"><span class="o">&gt;=</span></code>-Restriktionen) linken und
der rechten Seite aus. Sie hat in ihrer Restriktion den Koeffizienten <code class="highlight"><span class="mi">1</span></code> (für <code class="highlight"><span class="o">&lt;=</span></code>) bzw. <code class="highlight"><span class="o">-</span><span class="mi">1</span></code> (für <code class="highlight"><span class="o">&gt;=</span></code>) und
in allen anderen Restriktionen sowie der Zielfunktion den Koeffizienten <code class="highlight"><span class="mi">0</span></code>. Für <code class="highlight"><span class="o">=</span></code>-Restriktionen
sind prinzipiell keine Schlupfvariablen erforderlich, da hier kein Freiheitsgrad besteht (keine
akzeptable Differenz zwischen linker und rechter Seite).</p>
<p>Für das obige Beispiel ergibt sich damit folgendes Gleichungssystem:</p>
<div class="highlight"><pre><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="mi">4</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">s1</span>          <span class="o">=</span> <span class="mi">320</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">x2</span>          <span class="o">-</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">s2</span> <span class="o">=</span> <span class="mi">100</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="mi">3</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x2</span>                   <span class="o">=</span> <span class="mi">270</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">x2</span>                   <span class="o">=</span> <span class="o">-</span><span class="n">z</span> <span class="p">(</span><span class="n">MAX</span><span class="p">)</span>
</pre></div>

<p>Problematisch an diesem Gleichungssystem ist jedoch, dass es durch eine
Ausgangslösung mit (<code class="highlight"><span class="n">x1</span><span class="p">..</span><span class="n">xn</span></code> = 0) nicht erfüllt wird. Für Gleichung (3) ist dieses Problem
offensichtlich (<code class="highlight"><span class="mi">0</span> <span class="o">=</span> <span class="mi">270</span></code>), in Gleichung (2) müsste die Schlupfvariable <em>s2</em> zunächst einen Wert
von –100 aufweisen (2 * 0 + 4 * 0 - (–100) = 100). <em>s2</em> würde damit eine Untererfüllung der
entsprechenden Restriktion anzeigen; mithin dürfen Schlupfvariablen im Verfahren ebensowenig
negativ werden wie die Variablen
unseres LOP (die sogenannten Entscheidungsvariablen). </p>
<p>Um diesem Problem zu begegnen, führen wir in <code class="highlight"><span class="o">&gt;=</span></code>- und <code class="highlight"><span class="o">=</span></code>-Restriktionen zusätzlich die sogenannten
künstlichen Variablen ein, die die Untererfüllung von Restriktionen abbilden. Gleichung (2)
und (3) erhalten damit folgende Form:</p>
<div class="highlight"><pre><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">s2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">k2</span>          <span class="o">=</span> <span class="mi">100</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="mi">3</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x2</span>                   <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">270</span>
</pre></div>

<p>Die Schlupfvariable <em>s2</em> erhielte in dieser Gleichung zunächst den Wert 0, die neuen Variablen <em>k2</em>
und <em>k3</em> jeweils den Wert der rechten Seite (also hier 100 bzw. 270). Ausgehend von dieser
Gleichungsform kann nun das Ausgangstableau aufgestellt und eine modifizierte Variante des
Lösungsverfahrens durchgeführt werden. Zur Vereinfachung der Datenstruktur des
Simplex-Tableaus führen wir allerdings auch für <code class="highlight"><span class="o">&lt;=</span></code>-Restriktionen künstliche Variablen mit dem
Koeffizienten 0 ein und für =-Restriktionen Schlupfvariablen mit dem Koeffizienten 0. Es ergibt
sich damit für obiges Beispiel folgendes endgültiges Gleichungssystem: </p>
<div class="highlight"><pre><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="mi">4</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">s1</span>                   <span class="o">+</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">k1</span>                   <span class="o">=</span> <span class="mi">320</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">x2</span>          <span class="o">-</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">s2</span>                   <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">k2</span>          <span class="o">=</span> <span class="mi">100</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="mi">3</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x2</span>                   <span class="o">+</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">s3</span>                   <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">270</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">x2</span>                                                       <span class="o">=</span> <span class="o">-</span><span class="n">z</span>
</pre></div>

<h4>Erzeugen des Simplex-Ausgangstableaus</h4>
<p>Aus den Restriktionsgleichungen und der Zielfunktion wird das
Ausgangstableau für das Simplex-Verfahren gebildet, das als Matrix
(zweidimensionales Array) repräsentiert werden kann. Diese Matrix
enthält alle Koeffizienten (Restriktionen und Zielfunktion) des
Gleichungssystems sowie als letzte Spalte die Werte der rechten Seiten
(RS). In der Zeile der Zielfunktion entspricht die rechte Seite im
Ausgangstableau dem Wert 0. </p>
<p>Die Lösung des Gleichungssystems, für die ein Tableau steht, kann
zeilenweise abgelesen werden: Die auf der linken Seite (der
sogenannten <strong>Basis</strong>) eingetragenen Variablen haben die auf der rechten
Seite (rechts vom <code class="highlight"><span class="o">=</span></code>)dargestellten Werte. Zu Beginn werden in der Basis die genutzten Schlupf- und künstlichen Variablen
eingetragen, d.h. <code class="highlight"><span class="n">s1</span> <span class="o">=</span> <span class="mi">320</span></code>, <code class="highlight"><span class="n">k2</span> <span class="o">=</span> <span class="mi">100</span></code> und <code class="highlight"><span class="n">k3</span> <span class="o">=</span> <span class="mi">270</span></code>. Alle nicht in
der Basis eingetragenen Variablen haben den Wert 0. Achtet darauf nicht die Koeffizienten mit den Werten der Variablen zu
verwechseln.</p>
<p>Die ersten <code class="highlight"><span class="n">n</span></code> Spalten der Matrix entsprechen den Variablen des LOP, die folgenden <code class="highlight"><span class="n">m</span></code>
Spalten den Schlupfvariablen der Restriktionen (wobei <code class="highlight"><span class="n">m</span></code> die Anzahl der Restriktionen ist),
die folgenden <code class="highlight"><span class="n">m</span></code> Spalten den künstlichen Variablen der Restriktionen und die letzte Spalte
schließlich den rechten Seiten der Restriktionen.</p>
<p>An dieser Stelle wird der Vorteil der konsequenten Einführung von Schlupf- und künstlichen
Variablen deutlich (also Schlupfvariablen auch für =-Restriktionen und künstliche
Variablen auch für <code class="highlight"><span class="o">&lt;=</span></code>-Restriktionen): Aus dem Index einer Spalte kann durch einfache
Berechnung geschlossen werden, mit welcher Variablen die Spalte korrespondiert. Damit ist
es nicht erforderlich, eine Zuordnung von Spalten zu Variablen zu speichern. Dieser Vorteil
betrifft nicht nur die Verarbeitung der Spalten, sondern auch der Basis, in der die Speicherung der Spaltenindizes genügt.</p>
<p>Nachfolgend ist das Ausgangstableau zum obigen LOP abgebildet; dabei werden unter cols
bzw. rows die jeweiligen Spalten- / Zeilenindices ausgewiesen. </p>
<figure>
<img alt="Abbildung 1 - Ausgangstableau" src="./AuD-Aufgabe 1_files/img_01.png">
<figcaption>Abbildung 1 - Ausgangstableau</figcaption></figure>
<p>Die Ausgangslösung ist hier
demzufolge: <code class="highlight"><span class="n">x1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="mi">320</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">k3</span> <span class="o">=</span> <span class="mi">270</span></code>.
Es ist festzustellen, dass diese Lösung das lineare Programm nicht erfüllt; dies
ist wie oben erwähnt eine prinzipielle Folge der Einführung von <code class="highlight"><span class="o">&gt;=</span></code>- und =-Restriktionen
für die Ausgangslösung. </p>
<p>Grundsätzlich ist eine ungültige Lösung somit daran zu erkennen, dass in der Basis des Tableaus
min. eine künstliche Variable existiert.</p>
<h4>Optimierung der Lösung</h4>
<p>Eine Lösung ist noch nicht optimal, wenn keine gültige Lösung vorliegt oder ein Wert der Zielfunktionszeile größer als 0 sind.</p>
<p>Zur Optimierung wird jeweils eine Variable, die sich <strong>nicht</strong> in
der Basis befindet, mit einer Variable der Basis vertauscht. Dieser
Optimierungsschritt ist in die nachfolgenden Unterschritte aufgeteilt:</p>
<h5>1. Auswahl der Pivotspalte</h5>
<p>Zunächst muss die sogenannte Pivotspalte und mit ihr die Variable
bestimmt werden, die in die Basis getauscht werden soll.</p>
<p>Hier ist eine Fallunterscheidung notwendig, je nachdem, ob das Tableau
bereits eine gültige Lösung repräsentiert oder nicht (künstliche Variable
in der Basis).</p>
<p>Liegt eine gültige Lösung vor (also eine Lösung ohne künstliche Variable in der Basis),
so wird der größte positive Wert der Zielfunktionszeile (letzte Zeile)
als Auswahlkriterium genutzt. Ist der größte
Wert nicht eindeutig, wird von den größten Werten
der am weitesten links stehende ausgewählt.</p>
<p>Liegt hingegen wie im Beispiel noch keine gültige Lösung vor, so wird zunächst für jede Spalte
die Summe der Koeffizienten gebildet, die in Zeilen mit einer künstlichen Variable
als Basisvariable stehen. Im Beispiel ergibt sich für <em>x1</em> als Summe 5, für <em>x2</em> 7 und für
<em>s2</em> –1. Unter diesen Summen wird die Pivotspalte wie gehabt über den größten positiven Wert
ausgewählt. Nachfolgend wird die Auswahl nach diesem Verfahren am Tableau gezeigt. Für
die beschriebene Koeffizientensumme wird eine weitere Zeile unterhalb der Zielfunktionszeile
eingeführt; diese Zeile ist ein Gedankenmodell und wird <strong>nicht</strong> in der Matrix
abgespeichert.

<img alt="Abbildung 2 - Auswahl der Pivotspalte" src="./AuD-Aufgabe 1_files/img_02.png"> </p>

<p>Ist der größte Wert nicht eindeutig, so wird wie im ersten Fall der am weitesten links stehende Wert unter den größten
ausgewählt.</p>
<p>Für die Pivotspalte sind unabhängig von der Art der Auswahl nur die
Entscheidungs- und Schlupfvariablen zu berücksichtigen (also hier <em>x1</em> bis <em>s3</em>). </p>
<h5>2. Auswahl der Pivotzeile</h5>
<p>Nun ist die aus der Basis zu verdrängende Variable
auszuwählen, d.h. die sogenannte Pivotzeile. Dazu wird für jede
Zeile der Quotient Q aus der rechten Seite RS (Wert in der letzten
Spalte) und dem Koeffizienten in der ausgewählten Spalte gebildet,
hier: <code class="highlight"><span class="mi">320</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">107</span></code>, <code class="highlight"><span class="mi">100</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">=</span> <span class="mi">25</span></code> und <code class="highlight"><span class="mi">270</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">90</span></code>; für eine Division durch Null ergäbe sich der gedachte Wert “#”. Es wird nun die
Zeile mit dem kleinsten nicht-negativen Quotienten ausgewählt. Ist
dies nicht möglich (nur Q, die negativ oder # sind), so kann keine
optimale Lösung gefunden werden. Ist der kleinste Quotient nicht
eindeutig, so wird unter den kleinsten Quotienten die am weitesten
oben stehende Zeile ausgewählt.

<img alt="Abbildung 3 - Auswahl der Pivotzeile" src="./AuD-Aufgabe 1_files/img_03.png"> </p>
<h5>3. Austausch der Variablen / Normierung der Pivotzeile</h5>
<p>Die Variablen werden vertauscht. Außerdem wird die Pivotzeile
normiert, indem jeder Wert der Zeile (inkl. RS) durch das
Pivotelement (Wert an der Kreuzung von Pivotspalte und Pivotzeile)
dividiert wird.
<img alt="Abbildung 4 - Austausch der Variablen / Normierung der Pivotzeile" src="./AuD-Aufgabe 1_files/img_04.png"> </p>
<h5>4. Reduktion der anderen Zeilen</h5>
<p>Anschließend wird von jeder der übrigen Zeilen ein Vielfaches der
Pivotzeile abgezogen. Das Vielfache wird dabei so gewählt, dass in
der Pivotspalte eine 0 entsteht. <strong>Beispiel:</strong> Von der ersten Zeile
(Variable <em>s1</em>) ist das Dreifache der Pivotzeile abzuziehen, um aus
der 3 in der Pivotspalte eine 0 zu machen. Entsprechend wird von
den übrigen Zellen dieser Zeile jeweils das Dreifache der entsprechenden Zelle aus der Pivotzeile abgezogen.
<img alt="Abbildung 5 - Reduktion der anderen Zeilen" src="./AuD-Aufgabe 1_files/img_05.png"> </p>
<h4>Iteration / Abbruchbedingung</h4>
<p>Die Schritte 1 bis 4 werden solange wiederholt, bis das optimale Tableau erreicht wurde
(es liegt eine gültige Lösung vor und alle Werte der Zielfunktionszeile sind <code class="highlight"><span class="o">&lt;=</span></code> 0)
<img alt="Abbildung 6 - Iteration" src="./AuD-Aufgabe 1_files/img_06.png"></p>
<p>Neben dem Erreichen einer optimalen Lösung können während der Iteration folgende
Situationen eintreten, die ein Fortsetzen unmöglich machen:</p>
<ul>
<li>Es liegt keine gültige Lösung vor (es befindet sich noch eine künstliche Variable in der Basis) und
es kann keine Pivotspalte ausgewählt werden (keine Koeffizientensumme &gt; 0 gemäß Schritt 1);
in diesem Fall kann keine gültige Lösung gefunden werden.</li>
<li>Es liegt keine gültige Lösung vor (es befindet sich noch eine künstliche Variable in der Basis)<br>
und es kann keine Pivotzeile ausgewählt werden (keine Zeile mit <code class="highlight"><span class="n">q</span> <span class="o">&gt;=</span> <span class="mi">0</span></code>); in diesem Fall kann
keine gültige Lösung gefunden werden.</li>
<li>Es liegt eine gültige Lösung vor und es kann keine Pivotzeile ausgewählt werden (keine Zeile mit <code class="highlight"><span class="n">q</span> <span class="o">&gt;=</span> <span class="mi">0</span></code>);
in diesem Fall kann keine optimale Lösung gefunden werden.</li>
</ul>
<h4>Ergebnis</h4>
<p>Nun kann das Resultat abgelesen werden. Dabei ist zu jeder Variable
des Gleichungssystems ihr Wert anzugeben; für alle in der Basis
angegebenen Variablen entspricht ihr Wert der rechten Seite RS,
alle anderen haben den Wert 0. Der zugehörige optimale
Zielfunktionswert ist in der entsprechenden Zelle auf der rechten
Seite abzulesen, wobei der dort errechnete Wert beim Maximierungsproblem <code class="highlight"><span class="o">-</span><span class="n">z</span></code> entspricht und beim Minimierungsproblem
ohne Negierung übernommen werden kann. Die
Lösung des Beispiels lautet also: <code class="highlight"><span class="n">x1</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="mi">160</span><span class="p">,</span> <span class="n">s3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">420</span></code>.</p>
<h3>Berechung rationaler Zahlen</h3>
<p>Da es bei der maschinellen Verarbeitung von Gleitkommazahlen (beispielsweise <code class="highlight"><span class="kt">float</span></code>- oder <code class="highlight"><span class="kt">double</span></code>-Werten) zu
Ungenauigkeiten kommen kann, nutzen wir im Rahmen dieser Aufgabe rationale Zahlen, die durch eine Klasse für
Brüche repräsentiert werden. Die Repräsentation von Zahlen unterscheidet sich deshalb in unserem Programm
vom oben gezeigten Beispiel, welches jedoch für die Nachvollziehbarkeit des Algorithmus von Vorteil ist.</p>
<h3>Vorgaben und Implementierung</h3>
<p>Die zu implementierenden Methoden und Klassen sind bereits als Gerüst vorgegeben.
Ihr müsst bei dieser Aufgabe <strong>keine</strong> Kommandozeilenanwendung
erstellen, der Aufruf erfolgt ausschließlich über JUnit.</p>
<p>Die von euch zu vervollständigenden Klassen sind:</p>
<ul>
<li><code class="highlight"><span class="n">Fraction</span></code> zur Speicherung und Verrechnung von mathematischen Brüchen</li>
<li><code class="highlight"><span class="n">SimplexSolver</span></code> zur Lösung der Gleichungssysteme</li>
</ul>
<p>Die öffentlichen Schnittstellen dieser Klassen (also alles, was nicht <code class="highlight"><span class="n">private</span></code> ist) sind fest vorgegeben und
dürfen nicht verändert und damit auch nicht erweitert werden, gleiches gilt auch für bereits vollständig implementierte Methoden dieser Klassen. Private Hilfsmethoden und Attribute dürfen in der Klasse <code class="highlight"><span class="n">SimplexSolver</span></code> selbstverständlich hinzugefügt werden.</p>
<p>Zusätzlich zu diesen Klassen gibt es die bereits komplett vorgegebene Klassen <code class="highlight"><span class="n">LinearProgram</span></code>. Diese darf von euch nicht verändert werden.</p>
<p>Weitere Hilfsklassen solltet ihr nicht benötigen, daher ist deren Erstellung untersagt. Generell dürft ihr weder weitere Pakete importieren noch Datentypen aus der Java-Standardbibliothek verwenden. Einzige Ausnahme sind Methoden für Hilfsausgaben, welche selbstverständlich <code class="highlight"><span class="n">System</span><span class="p">.</span><span class="n">out</span></code> und <code class="highlight"><span class="n">System</span><span class="p">.</span><span class="n">err</span></code> und ggfs. auch bereits vorgefertigte Datentypen verwenden dürfen.</p>
<p>Alle vorgegebenen Dateien findet ihr im <a href="http://intern.fh-wedel.de/~mhe/spaud/aud-aufgaben/aufgabe1.tgz">Archiv</a> zu dieser Aufgabe.</p>
<h3>Brüche</h3>
<p>Die Klasse <code class="highlight"><span class="n">Fraction</span></code> repräsentiert vollständig gekürzte mathematische Brüche mit einem Zähler und einem Nenner. Die Zahl 0 wird durch den Zähler 0 und den Nenner 1 dargestellt. Der Nenner ist zudem niemals negativ, sodass zwei Brüche über den Vergleich des Zählers und des Nennners auf Gleichheit geprüft werden können. Dieser Vergleich ist bereits in der Methode <code class="highlight"><span class="n">equals</span></code> vorgegeben und darf nicht verändert werden. Als Randinfo: Die <code class="highlight"><span class="n">equals</span></code>-Methode ist eine der wenigen Stellen, an deren der <code class="highlight"><span class="n">instanceof</span></code>-Operator bzw. die Methode <code class="highlight"><span class="n">getClass</span></code> erlaubt und auch sinnvoll sind. Aus Konsistenzgründen ist zudem die Methode <code class="highlight"><span class="n">hashCode</span></code> implementiert, die ihr im Rahmen dieser Aufgabe igorieren könnt.</p>
<p>Die beiden einzigen Attribute der Klasse – <code class="highlight"><span class="n">numerator</span></code> (Zähler) und <code class="highlight"><span class="n">denominator</span></code> (Nenner) – sind als <code class="highlight"><span class="n">final</span></code> (unveränderlich) gekennzeichnet und dürfen somit nur einmalig im Konstruktor beschrieben werden. Die von euch zu implementierenden Methoden zum Addieren, Subtrahieren, Multiplizieren und Dividieren zweier Brüche müssen deshalb stets neue <code class="highlight"><span class="n">Fraction</span></code>-Instanzen zurückgeben, anstatt bereits bestehende Objekte zu verändern. Dies bietet dem Nutzer der Klasse die Möglichkeit, die selben Objekte an verschiedenen Stellen zu verwenden, ohne dabei Seiteneffekte beachten zu müssen. Bei der Verarbeitung können möglicherweise auftretende Überläufe der <code class="highlight"><span class="kt">long</span></code>-Werte im Rahmen dieser Aufgabe igoriert werden.</p>
<p>Um für zwei <code class="highlight"><span class="n">Fraction</span></code>-Instanzen sagen zu können, welche von beiden die größere Zahl repräsentiert, implementiert die Klasse die Schnittstelle <code class="highlight"><span class="nx">Comparable</span><span class="o">&lt;</span><span class="nx">Fraction</span><span class="o">&gt;</span></code>. Die zu implementierende Methode <code class="highlight"><span class="n">compareTo</span></code> gibt einen Wert kleiner als, gleich, oder größer als Null zurück, wenn der aktuelle Bruch die kleinere, die gleiche, oder die größere Zahl als der übergebene Bruch repräsentiert.</p>
<p>Zum Lesen der Werte des Bruchs sind verschiedene <code class="highlight"><span class="n">get</span><span class="o">*</span></code>-Methoden vorgegeben. Die Methode <code class="highlight"><span class="n">toString</span></code> liefert eine Stringrepräsentation des Bruchs zurück und kann u.a. zum Debuggen und für einfache Tests verwendet werden.</p>
<h3>Lineare Optimierungsprobleme</h3>
<p>Die bereits vollständig vorgegebene Klasse <code class="highlight"><span class="n">LinearProgram</span></code> repräsentiert lineare Optimierungsprobleme, die aus einer Menge von einzuhaltenen Restriktionen, einer Zielfunktion, und einer Optimierungsrichtung für diese Funktion bestehen (Minimierung bzw. Maximierung des Funktionswerts). Die Restriktionen wiederum enthalten ein Array von <code class="highlight"><span class="n">Fraction</span></code>-Instanzen für die Koeffizienten, einen Typen (Gleich, Kleiner-Gleich, oder Größer-Gleich), und eine <code class="highlight"><span class="n">Fraction</span></code>-Instanz für die rechte Seite der Ungleichung.</p>
<p><code class="highlight"><span class="n">LinearProgram</span></code>-Instanzen lassen sich über den vorgegebenen Konstruktor erstellen, ein Beispiel hierzu findet sich im Beispieltest (siehe <a href="http://intern.fh-wedel.de/~mhe/spaud/aud-aufgaben/aufgabe1.tgz">Archiv</a>). Die Attribute der Insatnzen können über verschiedene <code class="highlight"><span class="n">get</span><span class="o">*</span></code>-Methoden gelesen werden. Es ist nicht vorgesehen, bestehende Instanzen zu verändern.</p>
<h3>Simplex-Algorithmus</h3>
<p>Die Klasse <code class="highlight"><span class="n">SimplexSolver</span></code> repräsentiert einen Automaten zur Lösung linearer Optimierungsprobleme, der nach dem oben beschriebenen Algorithmus arbeiten soll. Nutzt zur Implementierung den Konstruktor (zur Erzeugen des Simplex-Ausgangstableaus), die Methode <code class="highlight"><span class="n">step</span></code> (für einen Optimierungs- / Iterationsschritt) und <code class="highlight"><span class="n">solve</span></code> (für die Durchführung der zur Lösung / zum Abbruch benötigten Iterationsschritte). Die Semantik der weiteren Methoden geht jeweils aus ihrer Javadoc-Beschreibung hervor.</p>
<h3>Hinweise zum Test</h3>
<p>Wir werden eure Programme automatisiert testen. Die Zugriffspunkte für die Tests sind hierbei die beiden öffentlichen Klassen <code class="highlight"><span class="n">Fraction</span></code> und <code class="highlight"><span class="n">SimplexSolver</span></code>. Achtet strikt darauf unsere Vorgaben nicht zu verändern. Da in der Klasse <code class="highlight"><span class="n">SimplexSolver</span></code> viele der in <code class="highlight"><span class="n">Fraction</span></code>
implementierten Methoden genutzt werden, ist es unabdingbar, dass diese fehlerfrei laufen.</p>
<p>Ein entsprechender Beispieltest ist im <a href="http://intern.fh-wedel.de/~mhe/spaud/aud-aufgaben/aufgabe1.tgz">Archiv</a> vorgegeben. Nutzt diesen als Vorlage für eigene Tests.</p>
<h3>Vorbedingungen</h3>
<p>Wie in den <a href="http://intern.fh-wedel.de/~mhe/spaud/aud-anforderungen.html">AuD-Anforderungen</a> beschrieben erwarten wir, dass ihr Vor- und Nachbedingungen
sämtlicher Methoden mittels Assertions sicherstellt. Für die Vorbedingungen der öffentlichen Methoden haben
wir dies bereits vorgegeben.</p>
<h3>Nicht-funktionale Mängel</h3>
<table>
<colgroup>
<col style="text-align:left;">
<col style="text-align:right;">
</colgroup>
<thead>
<tr>
<th style="text-align:left;">Nachbesserungsgrund</th>
<th style="text-align:right;">Abzug Prozentpunkte bei Nichterfüllung</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">Repository / Ordnerstruktur schlecht gepflegt</td>
<td style="text-align:right;">10</td>
</tr>
<tr>
<td style="text-align:left;">Mangelnde Codehygiene (z.B. toter Code)</td>
<td style="text-align:right;">5</td>
</tr>
<tr>
<td style="text-align:left;">Mangelhafte Dokumentation (z.B. Modul- oder Methodenköpfe / Inline-Kommentierung, Encodingprobleme)</td>
<td style="text-align:right;">5</td>
</tr>
<tr>
<td style="text-align:left;">Mangelhafte Formatierung / schlecht lesbarer Code (z.B. Einrückung)</td>
<td style="text-align:right;">5</td>
</tr>
<tr>
<td style="text-align:left;">Uneinheitliche Formatierung oder Sprachwahl für Bezeichner oder Kommentierung</td>
<td style="text-align:right;">5</td>
</tr>
<tr>
<td style="text-align:left;">Unangemessene Bezeichner (z.B. hinsichtlich ihrer Länge oder Aussagekraft)</td>
<td style="text-align:right;">5</td>
</tr>
<tr>
<td style="text-align:left;">Unangemessen viele Variablen</td>
<td style="text-align:right;">10</td>
</tr>
<tr>
<td style="text-align:left;">Unnötige / sinnlose Member-Variablen</td>
<td style="text-align:right;">10</td>
</tr>
<tr>
<td style="text-align:left;">Unnötige Codeverdopplung</td>
<td style="text-align:right;">20</td>
</tr>
<tr>
<td style="text-align:left;">Verwendung von unstrukturierter Programmierung (z.B. continues, unangemessen viele returns)</td>
<td style="text-align:right;">10</td>
</tr>
<tr>
<td style="text-align:left;">Ungeschickte Verwendung von programmatischen Konzepten (z.B. unpassendes static)</td>
<td style="text-align:right;">10</td>
</tr>
<tr>
<td style="text-align:left;">Kapselung mangelhaft (z.B. unpassende bzw. fehlende Sichtbarkeitsbereiche / Modifier)</td>
<td style="text-align:right;">10</td>
</tr>
<tr>
<td style="text-align:left;">Seiteneffekte unzureichend abgesichert</td>
<td style="text-align:right;">15</td>
</tr>
<tr>
<td style="text-align:left;">Laufzeit / Speicher-Effizienz mangelhaft (z.B. unnötige Verwendung von ineffizienten Methoden, unnötige Kopien, Zwischenergebnisse nicht wiederverwenden, unnötige Methodenaufrufe)</td>
<td style="text-align:right;">20</td>
</tr>
<tr>
<td style="text-align:left;">Nicht aufgabenkonforme Lösung (z.B. unzureichende Modularisierung)</td>
<td style="text-align:right;">20</td>
</tr>
</tbody>
</table>
<h3>Downloads</h3>
<p>Neben den vorgegeben <code class="highlight"><span class="p">.</span><span class="n">java</span></code>-Dateien findet ihr im <a href="http://intern.fh-wedel.de/~mhe/spaud/aud-aufgaben/aufgabe1.tgz">Archiv</a> zur Aufgabe
die Beispiel-JUnit-Testbench, sowie die aktuelle <code class="highlight"><span class="n">fh</span><span class="o">-</span><span class="n">checkstyle</span><span class="o">-</span><span class="n">config</span><span class="p">.</span><span class="n">xml</span></code> und <code class="highlight"><span class="n">build</span><span class="p">.</span><span class="n">xml</span></code>.</p>
<p>Die benötigten Bibliotheken für Checkstyle und JUnit findet ihr im <a href="http://intern.fh-wedel.de/~mhe/spaud/aud-aufgaben/tools.tgz">Tools-Archiv</a>.
In diesem ist ebenfalls die Konfigurationsdatei für den Eclipseformatter enthalten.</p>
<p>Die in der Aufgabenvorstellung gezeigten Folien findet ihr <a href="http://intern.fh-wedel.de/~mhe/spaud/aud-aufgaben/aufgabe1.pdf">hier</a>.</p>
            <div style="text-align:right; font-style:italic; margin-top: 14pt">letzte Änderung: 19.10.2018 13:21</div>            <!-- END: DOCUMENT COLUMN -->

          </div>
        </div>

        <div style="clear:both; height:50px;"></div>
      </div> <!-- id:content -->

    </div> <!-- id:container -->
  </div> <!-- id:wrapper -->

</body></html>